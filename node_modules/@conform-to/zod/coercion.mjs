import { objectSpread2 as _objectSpread2 } from './_virtual/_rollupPluginBabelHelpers.mjs';
import { any, ZodArray, ZodObject, ZodEffects, ZodOptional, ZodDefault, ZodCatch, ZodIntersection, ZodUnion, ZodDiscriminatedUnion, ZodTuple, ZodNullable, ZodPipeline, lazy } from 'zod';

/**
 * A special string value to represent empty string
 * Used to prevent empty string from being stripped to undefined when using `.default()`
 */
var EMPTY_STRING = '__EMPTY_STRING__';

/**
 * Helpers for coercing string value
 * Modify the value only if it's a string, otherwise return the value as-is
 */
function coerceString(value, transform) {
  if (typeof value !== 'string') {
    return value;
  }
  if (value === '') {
    return undefined;
  }
  if (value === EMPTY_STRING) {
    return '';
  }
  if (typeof transform !== 'function') {
    return value;
  }
  return transform(value);
}

/**
 * Helpers for coercing file
 * Modify the value only if it's a file, otherwise return the value as-is
 */
function coerceFile(file) {
  if (typeof File !== 'undefined' && file instanceof File && file.name === '' && file.size === 0) {
    return undefined;
  }
  return file;
}

/**
 * A file schema is usually defined as `z.instanceof(File)`
 * which is implemented based on ZodAny with `superRefine`
 * Check the `instanceOfType` function on zod for more info
 */
function isFileSchema(schema) {
  if (typeof File === 'undefined') {
    return false;
  }
  return schema._def.effect.type === 'refinement' && schema.innerType()._def.typeName === 'ZodAny' && schema.safeParse(new File([], '')).success && !schema.safeParse('').success;
}

/**
 * Reconstruct the provided schema with additional preprocessing steps
 * This strips empty values to undefined and coerces string to the correct type
 */
function enableTypeCoercion(type) {
  var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  var result = cache.get(type);

  // Return the cached schema if it's already processed
  // This is to prevent infinite recursion caused by z.lazy()
  if (result) {
    return result;
  }
  var schema = type;
  var def = type._def;
  if (def.typeName === 'ZodString' || def.typeName === 'ZodLiteral' || def.typeName === 'ZodEnum' || def.typeName === 'ZodNativeEnum') {
    schema = any().transform(value => coerceString(value)).pipe(type);
  } else if (def.typeName === 'ZodNumber') {
    schema = any().transform(value => coerceString(value, text => text.trim() === '' ? text : Number(text))).pipe(type);
  } else if (def.typeName === 'ZodBoolean') {
    schema = any().transform(value => coerceString(value, text => text === 'on' ? true : text)).pipe(type);
  } else if (def.typeName === 'ZodDate') {
    schema = any().transform(value => coerceString(value, text => {
      var date = new Date(text);

      // z.date() does not expose a quick way to set invalid_date error
      // This gets around it by returning the original string if it's invalid
      // See https://github.com/colinhacks/zod/issues/1526
      if (isNaN(date.getTime())) {
        return text;
      }
      return date;
    })).pipe(type);
  } else if (def.typeName === 'ZodBigInt') {
    schema = any().transform(value => coerceString(value, text => {
      if (text.trim() === '') {
        return text;
      }
      try {
        return BigInt(text);
      } catch (_unused) {
        return text;
      }
    })).pipe(type);
  } else if (def.typeName === 'ZodArray') {
    schema = any().transform(value => {
      // No preprocess needed if the value is already an array
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === 'undefined' || typeof coerceFile(coerceString(value)) === 'undefined') {
        return [];
      }

      // Wrap it in an array otherwise
      return [value];
    }).pipe(new ZodArray(_objectSpread2(_objectSpread2({}, def), {}, {
      type: enableTypeCoercion(def.type, cache)
    })));
  } else if (def.typeName === 'ZodObject') {
    schema = any().transform(value => {
      if (typeof value === 'undefined') {
        // Defaults it to an empty object
        return {};
      }
      return value;
    }).pipe(new ZodObject(_objectSpread2(_objectSpread2({}, def), {}, {
      shape: () => Object.fromEntries(Object.entries(def.shape()).map(_ref => {
        var [key, def] = _ref;
        return [key,
        // @ts-expect-error see message above
        enableTypeCoercion(def, cache)];
      }))
    })));
  } else if (def.typeName === 'ZodEffects') {
    if (isFileSchema(type)) {
      schema = any().transform(value => coerceFile(value)).pipe(type);
    } else {
      schema = new ZodEffects(_objectSpread2(_objectSpread2({}, def), {}, {
        schema: enableTypeCoercion(def.schema, cache)
      }));
    }
  } else if (def.typeName === 'ZodOptional') {
    schema = any().transform(value => coerceFile(coerceString(value))).pipe(new ZodOptional(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    })));
  } else if (def.typeName === 'ZodDefault') {
    schema = any().transform(value => coerceFile(coerceString(value))).pipe(new ZodDefault(_objectSpread2(_objectSpread2({}, def), {}, {
      defaultValue: () => {
        var value = def.defaultValue();
        if (value === '') {
          return EMPTY_STRING;
        }
        return value;
      },
      innerType: enableTypeCoercion(def.innerType, cache)
    })));
  } else if (def.typeName === 'ZodCatch') {
    schema = new ZodCatch(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    }));
  } else if (def.typeName === 'ZodIntersection') {
    schema = new ZodIntersection(_objectSpread2(_objectSpread2({}, def), {}, {
      left: enableTypeCoercion(def.left, cache),
      right: enableTypeCoercion(def.right, cache)
    }));
  } else if (def.typeName === 'ZodUnion') {
    schema = new ZodUnion(_objectSpread2(_objectSpread2({}, def), {}, {
      options: def.options.map(option => enableTypeCoercion(option, cache))
    }));
  } else if (def.typeName === 'ZodDiscriminatedUnion') {
    schema = new ZodDiscriminatedUnion(_objectSpread2(_objectSpread2({}, def), {}, {
      options: def.options.map(option => enableTypeCoercion(option, cache)),
      optionsMap: new Map(Array.from(def.optionsMap.entries()).map(_ref2 => {
        var [discriminator, option] = _ref2;
        return [discriminator, enableTypeCoercion(option, cache)];
      }))
    }));
  } else if (def.typeName === 'ZodTuple') {
    schema = new ZodTuple(_objectSpread2(_objectSpread2({}, def), {}, {
      items: def.items.map(item => enableTypeCoercion(item, cache))
    }));
  } else if (def.typeName === 'ZodNullable') {
    schema = new ZodNullable(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    }));
  } else if (def.typeName === 'ZodPipeline') {
    schema = new ZodPipeline(_objectSpread2(_objectSpread2({}, def), {}, {
      in: enableTypeCoercion(def.in, cache),
      out: enableTypeCoercion(def.out, cache)
    }));
  } else if (def.typeName === 'ZodLazy') {
    var inner = def.getter();
    schema = lazy(() => enableTypeCoercion(inner, cache));
  }
  if (type !== schema) {
    cache.set(type, schema);
  }
  return schema;
}

export { coerceFile, coerceString, enableTypeCoercion, isFileSchema };
