'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');

var keys = ['required', 'minLength', 'maxLength', 'min', 'max', 'step', 'multiple', 'pattern'];
function getZodConstraint(schema) {
  function updateConstraint(schema, data) {
    var _data$name;
    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var constraint = name !== '' ? (_data$name = data[name]) !== null && _data$name !== void 0 ? _data$name : data[name] = {
      required: true
    } : {};
    var def = schema['_def'];
    if (def.typeName === 'ZodObject') {
      for (var key in def.shape()) {
        updateConstraint(def.shape()[key], data, name ? "".concat(name, ".").concat(key) : key);
      }
    } else if (def.typeName === 'ZodEffects') {
      updateConstraint(def.schema, data, name);
    } else if (def.typeName === 'ZodPipeline') {
      // FIXME: What to do with .pipe()?
      updateConstraint(def.out, data, name);
    } else if (def.typeName === 'ZodIntersection') {
      var leftResult = {};
      var rightResult = {};
      updateConstraint(def.left, leftResult, name);
      updateConstraint(def.right, rightResult, name);
      Object.assign(data, leftResult, rightResult);
    } else if (def.typeName === 'ZodUnion' || def.typeName === 'ZodDiscriminatedUnion') {
      Object.assign(data, def.options.map(option => {
        var result = {};
        updateConstraint(option, result, name);
        return result;
      }).reduce((prev, next) => {
        var list = new Set([...Object.keys(prev), ...Object.keys(next)]);
        var result = {};
        for (var _name of list) {
          var prevConstraint = prev[_name];
          var nextConstraint = next[_name];
          if (prevConstraint && nextConstraint) {
            var _constraint = {};
            result[_name] = _constraint;
            for (var _key of keys) {
              if (typeof prevConstraint[_key] !== 'undefined' && typeof nextConstraint[_key] !== 'undefined' && prevConstraint[_key] === nextConstraint[_key]) {
                // @ts-expect-error Both are on the same type
                _constraint[_key] = prevConstraint[_key];
              }
            }
          } else {
            result[_name] = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, prevConstraint), nextConstraint), {}, {
              required: false
            });
          }
        }
        return result;
      }));
    } else if (name === '') {
      // All the cases below are not allowed on root
      throw new Error('Unsupported schema');
    } else if (def.typeName === 'ZodArray') {
      constraint.multiple = true;
      updateConstraint(def.type, data, "".concat(name, "[]"));
    } else if (def.typeName === 'ZodString') {
      var _schema = schema;
      if (_schema.minLength !== null) {
        var _schema$minLength;
        constraint.minLength = (_schema$minLength = _schema.minLength) !== null && _schema$minLength !== void 0 ? _schema$minLength : undefined;
      }
      if (_schema.maxLength !== null) {
        constraint.maxLength = _schema.maxLength;
      }
    } else if (def.typeName === 'ZodOptional') {
      constraint.required = false;
      updateConstraint(def.innerType, data, name);
    } else if (def.typeName === 'ZodDefault') {
      constraint.required = false;
      updateConstraint(def.innerType, data, name);
    } else if (def.typeName === 'ZodNumber') {
      var _schema2 = schema;
      if (_schema2.minValue !== null) {
        constraint.min = _schema2.minValue;
      }
      if (_schema2.maxValue !== null) {
        constraint.max = _schema2.maxValue;
      }
    } else if (def.typeName === 'ZodEnum') {
      constraint.pattern = def.values.map(option =>
      // To escape unsafe characters on regex
      option.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')).join('|');
    } else if (def.typeName === 'ZodTuple') {
      for (var i = 0; i < def.items.length; i++) {
        updateConstraint(def.items[i], data, "".concat(name, "[").concat(i, "]"));
      }
    } else if (def.typeName === 'ZodLazy') ;
  }
  var result = {};
  updateConstraint(schema, result);
  return result;
}

exports.getZodConstraint = getZodConstraint;
