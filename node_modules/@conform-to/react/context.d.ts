import { type Constraint, type Combine, type FormId, type FieldName, type FormContext as BaseFormContext, type FormValue, type FormState, type Intent, type SubscriptionScope, type SubscriptionSubject, type FormOptions as BaseFormOptions } from '@conform-to/dom';
import { type FormEvent, type ReactElement, type ReactNode, type MutableRefObject } from 'react';
export type Pretty<T> = {
    [K in keyof T]: T[K];
} & {};
export type Primitive = string | number | bigint | boolean | Date | File | null | undefined;
export type Metadata<Schema, FormSchema extends Record<string, unknown>, FormError = string[]> = {
    key: string | undefined;
    id: string;
    errorId: string;
    descriptionId: string;
    name: FieldName<Schema, FormSchema, FormError>;
    initialValue: FormValue<Schema>;
    value: FormValue<Schema>;
    errors: FormError | undefined;
    allErrors: Record<string, FormError>;
    valid: boolean;
    dirty: boolean;
};
export type FormMetadata<Schema extends Record<string, unknown> = Record<string, unknown>, FormError = string[]> = Omit<Metadata<Schema, Schema, FormError>, 'id'> & Pick<FormContext<Schema, FormError>, Intent['type']> & {
    id: FormId<Schema, FormError>;
    context: Wrapped<FormContext<Schema, FormError>>;
    status?: 'success' | 'error';
    getFieldset: () => Required<{
        [Key in keyof Combine<Schema>]: FieldMetadata<Combine<Schema>[Key], Schema, FormError>;
    }>;
    onSubmit: (event: React.FormEvent<HTMLFormElement>) => void;
    noValidate: boolean;
};
type SubfieldMetadata<Schema, FormSchema extends Record<string, any>, FormError> = [Schema] extends [Primitive] ? {} : [Schema] extends [Array<infer Item> | null | undefined] ? {
    getFieldList: () => Array<FieldMetadata<Item, FormSchema, FormError>>;
} : [Schema] extends [Record<string, any> | null | undefined] ? {
    getFieldset: () => Required<{
        [Key in keyof Combine<Schema>]: FieldMetadata<Combine<Schema>[Key], FormSchema, FormError>;
    }>;
} : {};
export type FieldMetadata<Schema = unknown, FormSchema extends Record<string, any> = Record<string, unknown>, FormError = string[]> = Metadata<Schema, FormSchema, FormError> & Constraint & {
    formId: FormId<FormSchema, FormError>;
} & SubfieldMetadata<Schema, FormSchema, FormError>;
export declare const Form: import("react").Context<FormContext<any, string[], any>[]>;
declare const wrappedSymbol: unique symbol;
export type Wrapped<Type> = {
    [wrappedSymbol]: Type;
};
export declare function getWrappedFormContext(context: Wrapped<FormContext>): FormContext;
export declare function useFormContext<Schema extends Record<string, any>, FormError>(formId?: FormId<Schema, FormError>): FormContext<Schema, FormError, unknown>;
export declare function useFormState<FormError>(form: FormContext<any, FormError>, subjectRef?: MutableRefObject<SubscriptionSubject>): FormState<FormError>;
export declare function FormProvider(props: {
    context: Wrapped<FormContext<any, any>>;
    children: ReactNode;
}): ReactElement;
export declare function FormStateInput(props: {
    formId?: string;
}): React.ReactElement;
export declare function useSubjectRef(initialSubject?: SubscriptionSubject): MutableRefObject<SubscriptionSubject>;
export declare function updateSubjectRef(ref: MutableRefObject<SubscriptionSubject>, subject: 'status' | 'formId'): void;
export declare function updateSubjectRef(ref: MutableRefObject<SubscriptionSubject>, subject: Exclude<keyof SubscriptionSubject, 'status' | 'formId'>, scope: keyof SubscriptionScope, name: string): void;
export declare function getMetadata<Schema, FormError, FormSchema extends Record<string, any>>(context: FormContext<FormSchema, FormError, any>, subjectRef: MutableRefObject<SubscriptionSubject>, stateSnapshot: FormState<FormError>, name?: FieldName<Schema, FormSchema, FormError>): Metadata<Schema, FormSchema, FormError>;
export declare function getFieldMetadata<Schema, FormSchema extends Record<string, any>, FormError>(context: FormContext<FormSchema, FormError, any>, subjectRef: MutableRefObject<SubscriptionSubject>, stateSnapshot: FormState<FormError>, prefix?: string, key?: string | number): FieldMetadata<Schema, FormSchema, FormError>;
export declare function getFormMetadata<Schema extends Record<string, any>, FormError = string[], FormValue = Schema>(context: FormContext<Schema, FormError, FormValue>, subjectRef: MutableRefObject<SubscriptionSubject>, stateSnapshot: FormState<FormError>, noValidate: boolean): FormMetadata<Schema, FormError>;
export type FormOptions<Schema extends Record<string, any> = any, FormError = string[], FormValue = Schema> = BaseFormOptions<Schema, FormError, FormValue> & {
    /**
     * A function to be called before the form is submitted.
     */
    onSubmit?: (event: FormEvent<HTMLFormElement>, context: ReturnType<BaseFormContext<Schema, FormError, FormValue>['submit']>) => void;
};
export type FormContext<Schema extends Record<string, any> = any, FormError = string[], FormValue = Schema> = Omit<BaseFormContext<Schema, FormError, FormValue>, 'submit' | 'onUpdate'> & {
    submit: (event: FormEvent<HTMLFormElement>) => void;
    onUpdate: (options: Partial<FormOptions<Schema, FormError, FormValue>>) => void;
};
export declare function createFormContext<Schema extends Record<string, any> = any, FormError = string[], FormValue = Schema>(options: FormOptions<Schema, FormError, FormValue>): FormContext<Schema, FormError, FormValue>;
export {};
